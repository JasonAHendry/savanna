from typing import List, Union
from abc import ABC, abstractmethod

from .barcode import BarcodeAnalysis
from savanna.util.metadata import MetadataTableParser, check_barcode_format
from savanna.util.dirs import ExperimentDirectories


class BarcodeAnalysisResults(dict):
    """
    Dictionary where keys are barcode name, and values
    are tuple of a bool (indicating whether analysis was successful),
    and a List[str] of generated output files

    {
        barcode01: (True, [outputs]),
        barcode02: (False, [outputs])
    }

    This object is generated by every `ExperimentAnalysis`, in the
    `def _run()` method.

    It can be used in the `def _summarise()` method to skip summarising
    failed barcodes, and to more easily get paths to output files.

    TODO BUG:
    - Currently, *only* generated if pipeline is run

    """

    def __init__(self, barcodes: List[str]):
        """
        Initialise as all barcodes failing and no outputs

        """
        for barcode in barcodes:
            self[barcode] = (False, [])

    def __setitem__(self, key: str, value: Union[bool, List[str]]):
        """
        Added a variety of checks to make sure the assigment is valid

        """

        # Barcode as key
        check_barcode_format(key, try_to_fix=False)

        # Values as (bool, List[str])
        if not isinstance(value, tuple):
            raise TypeError(
                f"With {self.__class__.__name__} dictionary, value must be (bool, List[str])."
            )

        success, outputs = value
        if not isinstance(success, bool):
            raise TypeError(
                f"With {self.__class__.__name__} dictionary, value must be (bool, List[str])."
            )
        if not isinstance(outputs, List):
            raise TypeError(
                f"With {self.__class__.__name__} dictionary, value must be (bool, List[str])."
            )

        super().__setitem__(key, value)


# This needs some documentation
class ExperimentAnalysis(ABC):
    """
    Perform a given per-barcode analysis across an entire experiment (e.g.
    all of the barcodes in that exeperiment); and the optionally
    summarise the results and produce a plot

    To Define                       Purpose
    def _get_barcode_analysis()     What barcode analysis should be run
                                        - return a BarcodeAnalysis
                                        - helpful to specific other keyword arguments
    def _summarise()                How should we summarise results across barcodes?
                                        -


    """

    def __init__(
        self,
        expt_dirs: ExperimentDirectories,
        metadata: MetadataTableParser,
        only_barcode: str = None,
        only_summary: bool = False,
        make_plot: bool = True,
    ):

        # Storage
        self.expt_dirs = expt_dirs
        self.metadata = metadata

        # Behaviour modifiers
        self.only_barcode = self._set_only_barcode(only_barcode)
        self.only_summary = only_summary
        self.make_plot = make_plot

        # Object pointing to expected results
        self.results = None

    def _set_only_barcode(self, only_barcode: str):
        """
        Check that the `only_barcode` argument conforms to a valid
        barcode within the metadata

        """
        if only_barcode in [None, "unclassified"]:
            return only_barcode

        only_barcode = check_barcode_format(only_barcode, try_to_fix=True)
        if not only_barcode in self.metadata.barcodes:
            raise ValueError(
                f"Barcode {only_barcode} cannot be analysed, it is not in {self.metadata.csv}"
            )
        return only_barcode

    @abstractmethod
    def _get_barcode_analysis(self, barcode_name: str) -> BarcodeAnalysis:
        pass

    def _run(self, barcodes: List[str]) -> BarcodeAnalysisResults:
        """
        Run a specific `BarcodeAnalysis` for a list of barcodes

        Note on usage:
        - In some subclasses, this will get overridden with 'pass' or simply
        a check for the correct input files.
        - Ultimately, self._summarise() will often expect a success = List[bool],
        as it will only perform summaries for barcodes where the analysis has run
        successfully or the expected input files were found; otherwise it
        should log a warning.

        """

        results = BarcodeAnalysisResults(barcodes)
        for b in barcodes:
            barcode_analysis = self._get_barcode_analysis(b)
            s = barcode_analysis.run()
            results[b] = (
                s,
                barcode_analysis.outputs,
            )  # Would need to specify regardless
        return results

    @abstractmethod
    def _summarise(self):
        pass

    @abstractmethod
    def _plot(self):
        pass

    def run(self):
        """
        Run the experiment analysis, optionally only running for a single
        barcode, performing just the summary, or not plotting

        """

        # Run analysis for a set of barcodes
        if not self.only_summary:
            if self.only_barcode is not None:
                self._run([self.only_barcode])
                return
            self.results = self._run(self.metadata.barcodes)

        # Summarise across barcodes
        # PROBLEM! self.results not populated unless run...
        self._summarise()

        # Optionally plot
        if self.make_plot:
            self._plot()

